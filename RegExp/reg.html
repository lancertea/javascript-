<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Regexp</title>

</head>

<body>
    <script>
        var s = 'loading'
        var reg1 = /ing/; //  /\d+/
        var reg2 = new RegExp('ing'); //  "\\d+"
        //写法2与写法1的区别是：写法2里面的参数可以是变量
        //另外写法2里面的参数是一个字符串，所以需要转义
        console.log(reg1.test(s));
        console.log(reg2.test(s));

        //注意两个方法的区别
        console.log(reg1.exec(s)); //Array [ "ing" ]
        console.log(s.match(reg1)); //Array [ "ing" ]

        /*
       常用方法总结：
       RegExpObject.exec(string)
       如果 exec() 找到了匹配的文本，则返回一个结果数组。否则，返回 null。
       此数组的第 0 个元素是与正则表达式相匹配的文本，第 1 个元素是与 RegExpObject 的第 1 个子表达式相匹配的文本
      （如果有的话），第 2 个元素是与 RegExpObject 的第 2 个子表达式相匹配的文本（如果有的话），以此类推。
       除了数组元素和 length 属性之外，exec() 方法还返回两个属性。
       index 属性声明的是匹配文本的第一个字符的位置。
       input 属性则存放的是被检索的字符串 string。
       在调用非全局的 RegExp 对象的 exec() 方法时，返回的数组与调用方法 String.match() 返回的数组是相同的。
       但是，当 RegExpObject 是一个全局正则表达式时，exec() 的行为就稍微复杂一些。
       它会在 RegExpObject 的 lastIndex 属性指定的字符处开始检索字符串 string。
       当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExpObject 的 lastIndex 属性设置为匹配文本的最后
       一个字符的下一个位置。这就是说，可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。
       当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。

       stringObject.match(searchvalue)
       stringObject.match(regexp)
       如果 regexp 没有标志 g，那么 match() 方法就只能在 stringObject 中执行一次匹配。如果没有找到任何匹配的文本， 
       match() 将返回 null。否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。该数组的第 0 个元素存放的是匹配文本，
       而其余的元素存放的是与正则表达式的子表达式匹配的文本。除了这些常规的数组元素之外，返回的数组还含有两个对象属性。
       
       index 属性声明的是匹配文本的起始字符在 stringObject 中的位置，
       input 属性声明的是对 stringObject 的引用。

       如果 regexp 具有标志 g，则 match() 方法将执行全局检索，找到 stringObject 中的所有匹配子字符串。若没有找到任何匹配的子串，则返回 null。
       如果找到了一个或多个匹配子串，则返回一个数组。不过全局匹配返回的数组的内容与前者大不相同，
       它的数组元素中存放的是 stringObject 中所有的匹配子串，而且也没有 index 属性或 input 属性。


       stringObject.replace(regexp/substr,replacement)

       RegExpObject.test(string)
       用于检测一个字符串是否匹配某个模式.如果字符串 string 中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false。
       */

       {
            //=>分组的第三个作用：“分组引用”
            let str = "book"; //=>"good"、"look"、"moon"、"foot"...
            let reg = /^[a-zA-Z]([a-zA-Z])\1[a-zA-Z]$/; //=>分组引用就是通过“\数字”让其代表和对应分组出现一模一样的内容
            console.log(reg.test("book")); //=>true
            console.log(reg.test("deep")); //=>true
            console.log(reg.test("some")); //=>false
        }

       
        //时间字符串格式化
        {
            String.prototype.formatTime = function (templete = "{0}年{1}月{2}日 {3}时{4}分{5}秒") {
                let timeAry = this.match(/\d+/g);
                return templete.replace(/\{(\d+)\}/g, (...[, $1]) => {
                    let time = timeAry[$1] || "00";
                    return time.length < 2 ? "0" + time : time;
                });
            }
            let time = "2019-8-13 16:51:3";
            console.log(time.formatTime());
            time = "2019/8/13";
            console.log(time.formatTime());
        }

        //格式化金钱
        {
            String.prototype.millimeter = function () {
                return this.replace(/\d{1,3}(?=(\d{3})+$)/g, content => content + ',');
            }


            //如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。
            //如果提供initialValue，从索引0开始。
            function format(str) {
                // var str = num + '';
                //[ "4", "5", "9", "8",  "2", "6", "5", "1"]
                return str.split("").reverse().reduce((prev, next, index) => {
                    return ((index % 3) ? next : (next + ',')) + prev;
                })
            }


            let num = "15628954"; //=>"15,628,954" 千分符
            console.log(num.millimeter());
            console.log(format(num));
            num = "112345678256874"; //=>"12,345,678,256,874"
            console.log(num.millimeter());
            console.log(format(num));
        }


        //如何把一个字符串的大小写取反（大写变小写小写变大写），例如 ’AbC' 变成 'aBc'
        //A-Z (65-90)
        {
            let str = '123aCedBBB';
            str = str.replace(/[a-zA-Z]/g, item => {
                return item.toUpperCase() === item ? item.toLowerCase() : item.toUpperCase();
            })
            console.log(str);

        }

        //在输入框中如何判断输入的是一个正确的网址，例如：用户输入一个字符串，验证是否符合URL网址的格式 2-7
        {
            let str = "https://www.zhufengpeixun.com.cn";
            let reg = /^(?:(http|https|ftp):\/\/)?((?:[\w-]+\.)+[a-z0-9]+)((?:\/[^/?#]*)+)?(\?[^#]+)?(#.+)?$/i;
            console.log(reg.exec(str));
            //=>URL格式
            //1.协议://  http/https/ftp
            //2.域名
            // www.zhufengpeixun.cn
            // zhufengpeixun.cn
            // kbs.sports.qq.com
            // kbs.sports.qq.com.cn
            //3.请求路径
            // /
            // /index.html
            // /stu/index.html
            // /stu/
            //4.问号传参
            // ?xxx=xxx&xxx=xxx
            //5.哈希值
            // #xxx

        }
    </script>
</body>

</html>