### 闭包
闭包的两大作用  
- 保护：私有变量和外界没有必然联系
- 保存：形成不销毁的栈内存，里面的私有变量等信息保存下来了

#### 堆栈内存释放问题（以谷歌webkit内核为例子）
函数执行就会形成栈内存（从内存中分配的一块空间），如果内存都不销毁释放，很容易就会导致栈内存溢出（内存爆满，电脑就卡死了）

- 堆内存释放
创建一个引用类型值，就会产生一个堆内存。如果当前创建的堆内存不被其它东西所占用了（浏览器会在空闲的时候，查找每一个内存的引用状况，不被占用的（为null）都会给回收释放掉），则会释放
```javascript
let obj = {
      name : 'zhufeng'
  };
let oop = obj;
//此时obj和oop都占用着对象的堆内存，想要释放堆内存，需要手动解除变量和值的关联（null：空对象指针）
obj = null;
oop = null;
```

- 栈内存释放
产生栈内存的方式：  
打开浏览器形成的全局作用域是栈内存  
手动执行函数形成的私有作用域是栈内存  
基于ES6中的let/const形成的块作用域也是栈内存  
....
   
栈内存释放：  
全局栈内存：关掉页面的时候才会销毁  
私有栈内存：  
1.一般情况下，函数只要执行完成，形成的私有栈内存就会被销毁释放掉（排除出现无限递归、出现死循环的模式）  
```javascript
function fn(){

    }
    fn(); //函数执行形成栈内存，执行完成栈内存销毁
```
2.一旦栈内存中的某个东西（一般都是堆地址）被私有作用域以外的事物给占用了，则当前私有栈内存不能立即被释放销毁（特点：私有作用域中的私有变量等信息也保留下来了）。市面上认为的闭包：函数执行形成不能被释放的私有栈内存，这样的情况才是闭包
```javascript
function X(){
    return function(){
            //...
    }
let f=X(); //=>f占用了X执行形成的栈内存中的一个东西（返回小函数对应的堆），则X执行形成的栈内存不能被释放了
```
```javascript
var i = 5;
function fn(i) {
    return function (n) {
        console.log(n + (++i));
    }
}
var f = fn(1);
f(2);
fn(3)(4);
fn(5)(6);
f(7);
console.log(i)
```    
```javascript
var i = 20;
function fn() {
    i -= 2;
    return function (n) {
    console.log((++i) - n);
    }
}
var f = fn();
f(1);
f(2);
fn()(3);
fn()(4);
f(5);
console.log(i);
```    
   
