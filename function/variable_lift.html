<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>变量提升</title>
    <style>

    </style>
</head>

<body>
    <script>
        //变量提升
        //变量的提升是以变量作用域来决定的，即全局作用域中声明的变量会提升至全局最顶层，
        //函数内声明的变量只会提升至该函数作用域最顶层。

        // var 关键字变量提升
        // console.log(a); //undefined
        // var a = 0;



        //let 关键字“暂时性死区”
        //let 定义变量是有一个“特殊声明”的过程，JS 预解析的时候，先将定义的 let ,const “特殊声明”提前，
        //类似“举手”，JS 引擎规定了同一个作用域，同一个变量只能被一次“举手”。
        //它也不是报错 x not defined，而是 Cannot access。
        //实际上代码中赋值的x变量还没读取（在读取变量的时候才可能抛变量未定义的错误）。

        // var x = 0;
        // function a() {
        //  console.log(x); //can't access lexical declaration `x' before initialization
        //  let x = 1;
        // }
        // a();




        //函数声明提升会覆盖变量提升，函数表达式不会声明提升
        // console.log(a); //function a()  
        // var a = 1
        // console.log(a); //1 
        // function a() {}
        // console.log(a); //1


        //块级作用域
        //如果是变量提升，是不存在块级作用域的，但是函数提升是存在的
        //函数 function a(){} 在经过预解析之后，将函数声明提到函数级作用域最前面(这里是全局)，
        //然后将函数定义提升到块级作用域最前面。
        // console.log(a); // undefined
        // if (true) {
        //     console.log(a); // function a()
        //     function a() {}
        // }

        //函数声明提到函数级作用域最前面(这里是全局)，函数定义提升到块级作用域最前面
        console.log(b); //undefined
        console.log(c); //function c()
        c(); //'c'
        //b(); 报错
        if (true) {
            function b() {
                console.log('b');

            }
        }
        b(); //'b'
        function c() {
            console.log('c');

        }


        var a = 0;
        console.log(a, window.a); //0  0
        //a();  报错，说明函数定义是块级作用域，如果注释掉第一句，上一句输出两个undefined，说明函数声明是提升到全局位置了

        if (true) {
            a(); //'function'  函数声明提到函数级作用域最前面(这里是全局)，函数定义提升到块级作用域最前面
            console.log(a, window.a); //输出 function a 和 0
            a = 1; // 取作用域最近的块级作用域的 function a ,且被重置为 1了，本质又是一个变量的赋值。
            console.log(a, window.a); // a 是指向块级作用域的 a, 输出 1 和 0 
            function a() {
                console.log('function');
            } // 函数的声明，将执行函数的变量的定义同步到函数级的作用域。
            console.log(a, window.a); // 输出 1 和 1
            a = 21; // 仍然是函数定义块级作用域的 a ,重置为 21
            console.log(a, window.a); // 输出为函数提升的块级作用域的 a, 输出 21，1
            console.log("里面", a);
        }
        console.log("外部", a);


        //var funciton变量提升的区别
        fn();

        function fn() {
            console.log(1);
        }
        fn();

        function fn() {
            console.log(2);
        }
        fn();
        var fn = function () {
            console.log(3);
        }
        fn();

        function fn() {
            console.log(4);
        }
        fn();

        function fn() {
            console.log(5);
        }
        fn();

        //形参会变量提升，并赋值，不能用let重新声明
        /* function sum(a) {
        	console.log(a);
        	let a = 100; //=>Uncaught SyntaxError: Identifier 'a' has already been declared
        	console.log(a);
        }
        sum(200);

        function sum(a) {
        	console.log(a);
        	var a = 100; 
        	console.log(a);
        }
        sum(200); //200  100


        */


        //关于条件判断的           
        /*
         * 全局作用域
         *   1.变量提升  
         *     不管条件是否成立都要进行变量提升
         *     var a;  //=>创建一个全局变量a  =>window.a
         *   2.代码执行
         */
        // console.log(a); //=>undefined
        // if (!('a' in window)) { //=>'a' in window  =>TRUE
        // 	var a = 13;
        // }
        // console.log(a); //=>undefined

        /*
         * 全局作用域
         *   1.变量提升  
         *     但是做函数的有特殊性：在老版本浏览器中，确实不论条件是否成立，函数也是提前声明或者定义的，但是新版本浏览器中，为了兼容ES6严谨的语法规范，条件中的函数在变量提升阶段只能提前声明，不能提前定义
         *     function fn;
         *   2.代码执行
         */
        // console.log(fn); //=>undefined
        // // fn(); //=>Uncaught TypeError: fn is not a function
        // if ('fn' in window) { //=>TRUE
        // 	// 条件成立，进来后的第一件事是给FN赋值，然后在代码执行
        // 	fn(); //=>"哈哈哈"
        // 	function fn() {
        // 		console.log('哈哈哈');
        // 	}
        // }
        // fn(); //=>"哈哈哈"

        {
            var ary = [12, 23];

            function fn(ary) {
                console.log(ary);
                ary[0] = 100;
                ary = [100];
                ary[0] = 0;
                console.log(ary);
            }
            fn(ary);
            console.log(ary);
        }
    </script>
</body>

</html>