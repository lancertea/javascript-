<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>function</title>
    <script>
        /*
        变量声明和变量提升
        通常，各类文章和JavaScript相关的书籍都声称：“不管是使用var关键字(在全局上下文)还是不使用var关键字(在任何地方)，都可以声明一个变量”。
        请记住，这是错误的概念：任何时候，变量只能通过使用var关键字才能声明。

        a=10;
        这仅仅是给全局对象创建了一个新属性(但它不是变量)。“不是变量”并不是说它不能被改变，而是指它不符合ECMAScript规范中的变量概念，
        所以它“不是变量”(它之所以能成为全局对象的属性，完全是因为VO(globalContext) === global)。
        */
        console.log(a); //undefined
        //a没有报错的原因是a在稍后声明了，但这里输出的是undefined，因为JavaScript引擎自动提升了变量a的声明，但不会提升变量a的赋值。
        //console.log(b); 报错，'b'没有声明
        //因为“b”不是一个变量，所以在这个阶段根本就没有“b”，“b”将只在代码执行阶段才会出现(但是在这个例子里，还没有到那就已经出错了)。

        b = 10;
        var a = 20;

        //修改一下：
        console.log(c); // undefined

        d = 10;
        console.log(d); // 10, 代码执行阶段创建

        var c = 20;
        console.log(c); // 20, 代码执行阶段修改

        //变量相对于简单属性来说，变量有一个特性(attribute)：{DontDelete},这个特性的含义就是不能用delete操作符直接删除变量属性。
        e = 10;
        console.log(window.e); //10 

        console.log(delete e); //true

        console.log(window.e); //undefined   另外这里直接输出e,会报错,为什么呢

        var f = 20;
        console.log(window.f); //20

        console.log(delete f); //false

        console.log(window.f); //20



        //函数上下文中的变量对象
        function foo(x, y, z) {

            // 声明的函数参数数量arguments (x, y, z)
            console.log(foo.length); // 3

            // 真正传进来的参数个数(only x, y)
            console.log(arguments.length); // 2

            // 参数的callee是函数自身
            console.log(arguments.callee === foo); // true

            // 参数共享
            console.log(x === arguments[0]); // true
            console.log(x); // 10

            arguments[0] = 20;
            console.log(x); // 20

            x = 30;
            console.log(arguments[0]); // 30

            // 不过，没有传进来的参数z，和参数的第3个索引值是不共享的
            z = 40;
            console.log(arguments[2]); // undefined

            arguments[2] = 50;
            console.log(z); // 40

        }

        foo(10, 20);



        //立即调用的函数表达式
        

        //函数参数是对象的情况
        function test(person) {
            person.age = 26
            person = {
                name: 'yyy',
                age: 30
            }

            return person
        }
        const p1 = {
            name: 'hy',
            age: 25
        }
        const p2 = test(p1)
        //p1是引用，在调用test后，首先将p1的属性age改成了26
        console.log(p1) // -> {name: "hy", age: 26}
        console.log(p2) // -> {name: "yyy", age: 30}

        //有括号，返回函数调用的结果
        var p = test('jack'),
            //无括号，返回函数自身
            t = test;
        console.log(p); // -> {name: "yyy", age: 30}
        console.log(t);



        /*
        call()，apply()，bind()的用法：控制this的指向
        apply()：它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数
        call():与apply()类似，区别是apply()把参数打包成Array再传入，call()把参数按顺序传入


        对普通函数调用，我们通常把this绑定为null。
        https://www.cnblogs.com/Shd-Study/p/6560808.html
        */
        //例1
        var name = "小王",
            age = 17;
        var obj = {
            name: '小张',
            objAge: this.age, //this指向全局
            myFun: function () {
                console.log(this.name + '年龄' + this.age); //this指向对象
                console.log(this.name + '年龄' + this.objAge); //this指向对象
            }
        }
        console.log(obj.objAge); //17
        obj.myFun(); //'小张年龄undefined'
        //'小张年龄17'

        //例2
        var fav = 'klaus';

        function shows() {
            console.log(this.fav); //this指向全局

        }
        shows() //'klaus'

        //call()，apply()，bind()都是用来重定义this这个对象的
        var name = "小王",
            age = 17;
        var obj = {
            name: '小张',
            objAge: this.age, //this指向全局
            myFun: function () {
                console.log(this.name + '年龄' + this.age); //this指向对象

            }
        }
        var db = {
            name: '德玛',
            age: 99
        }
        obj.myFun.call(db); //'德玛年龄99'
        obj.myFun.apply(db) //'德玛年龄99'
        obj.myFun.bind(db)(); //'德玛年龄99'
        //以上除了bind方法后面多了个 () 外 ，结果返回都一致！
        //由此得出结论，bind 返回的是一个新的函数，你必须调用它才会被执行



        //hasOwnProperty()
        // 对象
        var man = {
            hands: 2,
            legs: 2,
            heads: 1
        };

        // 一个方法添加给了所有对象
        if (typeof Object.prototype.clone === "undefined") {
            Object.prototype.clone = function () {};
        }

        // 1.
        // for-in 循环
        for (var i in man) {
            if (man.hasOwnProperty(i)) { // 过滤
                console.log(i, ":", man[i]);
            }
        }
        /* 
        hands : 2
        legs : 2
        heads : 1
        */

        // 2.
        // 反面例子:
        // for-in loop without checking hasOwnProperty()
        for (var i in man) {
            console.log(i, ":", man[i]);
        }
        /*
        hands : 2
        legs : 2
        heads : 1
        clone: function()
        */

        //1的另一种写法：
        for (var i in man) {
            if (Object.prototype.hasOwnProperty.call(man, i)) { // 过滤
                console.log(i, ":", man[i]);
            }
        }
        /* 
        hands : 2
        legs : 2
        heads : 1
        */
        //其好处在于在man对象重新定义hasOwnProperty情况下避免命名冲突。也避免了长属性查找对象的所有方法，你可以使用局部变量“缓存”它。
        var i, hasOwn = Object.prototype.hasOwnProperty;
        for (i in man) {
            if (hasOwn.call(man, i)) { // 过滤
                console.log(i, ":", man[i]);
            }
        }
        /* 
        hands : 2
        legs : 2
        heads : 1
        */



        /*
        eval()
        当解析器发现代码中调用eval()方法时，它会将传入的参数当作实际的ECMAScript语句来解析，然后把执行结果插入到原位置。
        */
        eval('console.log("hi")'); //'hi'
        //这行代码的作用等价于下面这行
        console.log("hi"); //'hi'

        //通过eval()执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有该执行环境相同的作用域链。
        var msg = 'hello';
        eval('console.log(msg)'); //'hello'

        eval('function sayHi(){console.log("hi");}');
        sayHi(); //'hi'

        //在eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在eval()执行的时候创建
        //sayBye();// error,sayBye is not defined
        eval('function sayBye(){console.log("bye");}');

        /*
        避免eval()
        https://www.cnblogs.com/TomXu/archive/2011/12/28/2286877.html
        */



       
      


    </script>

</head>

<body>

</body>

</html>