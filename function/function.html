<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>function</title>
    <script>
        /*
        eval()
        当解析器发现代码中调用eval()方法时，它会将传入的参数当作实际的ECMAScript语句来解析，然后把执行结果插入到原位置。
        */
        eval('console.log("hi")'); //'hi'
        //这行代码的作用等价于下面这行
        console.log("hi"); //'hi'

        //通过eval()执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有该执行环境相同的作用域链。
        var msg = 'hello';
        eval('console.log(msg)'); //'hello'

        eval('function sayHi(){console.log("hi");}');
        sayHi(); //'hi'

        //在eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在eval()执行的时候创建
        //sayBye();// error,sayBye is not defined
        eval('function sayBye(){console.log("bye");}');

        /*
        避免eval()
        https://www.cnblogs.com/TomXu/archive/2011/12/28/2286877.html
        */



    

       

        //立即调用的函数表达式




        //函数参数是对象的情况
        function test(person) {
            person.age = 26
            person = {
                name: 'yyy',
                age: 30
            }

            return person
        }
        const p1 = {
            name: 'hy',
            age: 25
        }
        const p2 = test(p1)
        //p1是引用，在调用test后，首先将p1的属性age改成了26
        console.log(p1) // -> {name: "hy", age: 26}
        console.log(p2) // -> {name: "yyy", age: 30}

        //有括号，返回函数调用的结果
        var p = test('jack'),
            //无括号，返回函数自身
            t = test;
        console.log(p); // -> {name: "yyy", age: 30}
        console.log(t);



        /*
        call()，apply()，bind()的用法：控制this的指向
        apply()：它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数
        call():与apply()类似，区别是apply()把参数打包成Array再传入，call()把参数按顺序传入


        对普通函数调用，我们通常把this绑定为null。
        https://www.cnblogs.com/Shd-Study/p/6560808.html
        */
        //例1
        var name = "小王",
            age = 17;
        var obj = {
            name: '小张',
            objAge: this.age, //this指向全局
            myFun: function () {
                console.log(this.name + '年龄' + this.age); //this指向对象
                console.log(this.name + '年龄' + this.objAge); //this指向对象
            }
        }
        console.log(obj.objAge); //17
        obj.myFun(); //'小张年龄undefined'
        //'小张年龄17'

        //例2
        var fav = 'klaus';

        function shows() {
            console.log(this.fav); //this指向全局

        }
        shows() //'klaus'

        //call()，apply()，bind()都是用来重定义this这个对象的
        var name = "小王",
            age = 17;
        var obj = {
            name: '小张',
            objAge: this.age, //this指向全局
            myFun: function () {
                console.log(this.name + '年龄' + this.age); //this指向对象

            }
        }
        var db = {
            name: '德玛',
            age: 99
        }
        obj.myFun.call(db); //'德玛年龄99'
        obj.myFun.apply(db) //'德玛年龄99'
        obj.myFun.bind(db)(); //'德玛年龄99'
        //以上除了bind方法后面多了个 () 外 ，结果返回都一致！
        //由此得出结论，bind 返回的是一个新的函数，你必须调用它才会被执行



        //hasOwnProperty()
        // 对象
        var man = {
            hands: 2,
            legs: 2,
            heads: 1
        };

        // 一个方法添加给了所有对象
        if (typeof Object.prototype.clone === "undefined") {
            Object.prototype.clone = function () {};
        }

        // 1.
        // for-in 循环
        for (var i in man) {
            if (man.hasOwnProperty(i)) { // 过滤
                console.log(i, ":", man[i]);
            }
        }
        /* 
        hands : 2
        legs : 2
        heads : 1
        */

        // 2.
        // 反面例子:
        // for-in loop without checking hasOwnProperty()
        for (var i in man) {
            console.log(i, ":", man[i]);
        }
        /*
        hands : 2
        legs : 2
        heads : 1
        clone: function()
        */

        //1的另一种写法：
        for (var i in man) {
            if (Object.prototype.hasOwnProperty.call(man, i)) { // 过滤
                console.log(i, ":", man[i]);
            }
        }
        /* 
        hands : 2
        legs : 2
        heads : 1
        */
        //其好处在于在man对象重新定义hasOwnProperty情况下避免命名冲突。也避免了长属性查找对象的所有方法，你可以使用局部变量“缓存”它。
        var i, hasOwn = Object.prototype.hasOwnProperty;
        for (i in man) {
            if (hasOwn.call(man, i)) { // 过滤
                console.log(i, ":", man[i]);
            }
        }
        /* 
        hands : 2
        legs : 2
        heads : 1
        */
    </script>

</head>

<body>

</body>

</html>