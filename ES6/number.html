<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Number的扩展</title>
    <style>

    </style>
</head>

<body>

    <script>
        // 它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，
        // 而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，
        // 非NaN一律返回false。
        
        //Number.isFinite()
        console.log(Number.isFinite(15));//true
        console.log(Number.isFinite(NaN));//false
        console.log(Number.isFinite(Infinity));//false

        //如果参数类型不是数值，Number.isFinite一律返回false。
        console.log(Number.isFinite('foo'));//false
        //ES5 isFinite() 先调用Number()将非数值的值转为数值，再进行判断
        console.log(isFinite('15'));//true
        //ES6 只对数值有效
        console.log(Number.isFinite('15'));//false
        console.log(Number.isFinite(true));//false
        
        //Number.isNaN()
        console.log(Number.isNaN(NaN));//true
        console.log(Number.isNaN(15));//false
        console.log(Number.isNaN('15'));//false
        console.log(Number.isNaN(true));//false
        console.log(Number.isNaN('true'/0));//true

        //ES5 isNaN() 先调用Number()将非数值的值转为数值，再进行判断
        console.log(isNaN(NaN));//true
        console.log(isNaN('NaN'));//true
        //ES6 只对NaN返回true,非NaN一律返回false
        console.log(Number.isNaN(NaN));//true
        console.log(Number.isNaN('NaN'));//false

        /*
        // ES5的写法
        parseInt('12.34') // 12
        parseFloat('123.45#') // 123.45

        // ES6的写法
        Number.parseInt('12.34') // 12
        Number.parseFloat('123.45#') // 123.45

        这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。
        */
        
        //Number.isInteger()用来判断一个数值是否为整数。由于精度问题，存在误判问题
        //极小的常量：Number.EPSILON，表示 1 与大于 1 的最小浮点数之间的差。
        //对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。
        //Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。
        function withinErrorMargin(left, right) {
            return Math.abs(left - right) < Number.EPSILON * Math.pow(2, 2);
        }
        console.log(0.1 + 0.2 === 0.3);// false
        console.log(withinErrorMargin(0.1 + 0.2, 0.3));//true
        
       
        
        
    </script>
</body>

</html>
