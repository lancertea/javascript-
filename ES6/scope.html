<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>常量，作用域</title>
</head>
<script>
    // ES5 中常量的写法

    Object.defineProperty(window, "PI2", {
        value: 3.1415926,
        writable: false,
    })

    console.log(window.PI2)

    // ES6 的常量写法

    const PI = 3.1415926
    console.log(PI)

    // PI = 4


    // 作用域
    //ES5:只有两种作用域： 全局变量与函数内的局部变量
    {
        { //变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。
            for (var i = 0; i < 3; i++) {
                setTimeout(function () {
                    console.log(i); //3 3 3

                }, 100);
            }

        }
        //ES6:块级作用域
        {
            for (let i = 0; i < 3; i++) {
                setTimeout(function () {
                    console.log(i); // 0 1 2

                }, 100);
            }
        }

        {//注意这里，只有异步才会出现这种情况
            for (var i = 0; i < 3; i++) {
                console.log(i); //0,1,2

            }

            for (let i = 0; i < 3; i++) {
                console.log(i); //0,1,2

            }




        }

        {
            //立即执行函数（闭包）
            for (var i = 0; i < 3; i++) {
                // (function(){})();
                (function (j) { //j为形参
                    setTimeout(function () {
                        console.log(j); //0 1 2
                    }, 100);
                })(i); //i为实参

            }
        }
    }

    //暂时性死区
    //暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，
    //只有等到声明变量的那一行代码出现，才可以获取和使用该变量。
    //报错不是未定义，在读取变量的时候才可能抛变量未定义的错误
    var tmp = 123;
    var x = 2;

    if (true) {
        tmp = 'abc'; //can't access lexical declaration `x' before initialization
        let tmp;
    }

    //关于变量提升可参看function->variable_lift
</script>

<body>

</body>

</html>