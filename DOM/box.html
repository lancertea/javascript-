<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>盒子模型属性</title>
</head>

<body>
    

    <script>
/*
**JS盒子模型属性**

基于一些属性和方法，让我们能够获取到当前元素的样式信息，例如：clientWidth 、offsetWidth等

 - client
   - width / height
   - top / left
 - offset
   - width / height
   - top / left
   - parent
 - scroll
   - width / height
   - top / left

  方法：window.getComputedStyle([ELEMENT],[伪类]) / [ELEMENT].currentStyle

**client**
let box = document.getElementById('box');

获取盒子可视区域的宽高（内容宽度+左右padding）
1.内容溢出与否对他无影响
2.获取的结果是没有单位的（其余的盒模型属性也是）
3.获取的结果是整数，它会自己进行四舍五入（其余的盒模型属性也是）
box.clientWidth
box.clientHeight

获取当前页面一屏幕（可视化）区域的宽高
let winW = document.documentElement.clientWidth || document.body.clientWidth;
let winH = document.documentElement.clientHeight || document.body.clientHeight;

获取盒子左边框和上边框的大小(没有右下)
box.clientLeft
box.clientTop


**offset**
let box = document.getElementById('box');

在client的基础上加上border == 盒子本身的宽高
box.offsetWidth
box.offsetHeight


**scroll**
在没有内容溢出的情况下，获取的结果和client是一样的
在有内容溢出的情况下，获取的结果约等于真实内容的宽高（上/左PADDING + 真实内容的高度/宽度）
1.不同浏览器获取的结果不尽相同
2.设置overflow属性值对最后的结果也会产生一定的影响
box.scrollWidth
box.scrollHeight

//获取整个页面真实的高度
document.documentElement.scrollHeight || document.body.scrollHeight

box.scrollTop  竖向滚动条卷去的高度
box.scrollLeft  横向滚动条卷去的宽度

1.边界值
min=0
max=整个的高度scrollHeight - 一屏幕高度clientHeight
2.13个盒子模型属性，只有这两个是“可读写”的属性（既可以获取也可以设置对应的值），
其余的都是“只读”属性（不能设置值，只能获取）

常用：
盒子：
回到顶部：box.scrollTop=0
回到底部：box.scrollTop=box.scrollHeight-box.clientHeight

整个页面：
回到顶部：document.documentElement.scrollTop=0
回到底部：document.documentElement.scrollTop=document.documentElement.scrollHeight-document.documentElement.clientHeight

*/
      
    </script>
</body>

</html>