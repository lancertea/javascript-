<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>盒子模型属性</title>
</head>

<body>
    

    <script>
/*
**JS盒子模型属性**

基于一些属性和方法，让我们能够获取到当前元素的样式信息，例如：clientWidth 、offsetWidth等

 - client
   - width / height
   - top / left
 - offset
   - width / height
   - top / left
   - parent
 - scroll
   - width / height
   - top / left

**client**
let box = document.getElementById('box');

获取盒子可视区域的宽高（内容宽度+左右padding）
1.内容溢出与否对他无影响
2.获取的结果是没有单位的（其余的盒模型属性也是）
3.获取的结果是整数，它会自己进行四舍五入（其余的盒模型属性也是）
box.clientWidth
box.clientHeight

获取当前页面一屏幕（可视化）区域的宽高
let winW = document.documentElement.clientWidth || document.body.clientWidth;
let winH = document.documentElement.clientHeight || document.body.clientHeight;

获取盒子左边框和上边框的大小(没有右下)
box.clientLeft
box.clientTop


**offset**
let box = document.getElementById('box');

在client的基础上加上border == 盒子本身的宽高
box.offsetWidth
box.offsetHeight

offsetParent：获取它的父参照物（不一定是父元素）
父参照物和它的父元素没有必然的联系，父参照物查找：
同一个平面中，最外层元素是所有后代元素的父参照物，
而基于position:relative/absolute/fixed可以让元素脱离文档流（一个新的平面），从而改变元素的父参照物

document.body.offsetParent === null

offsetTop：距离其父参照物的上偏移
offsetLeft：距离其父参照物的左偏移（当前元素的外边框到父参照物的里边框）


**scroll**
在没有内容溢出的情况下，获取的结果和client是一样的
在有内容溢出的情况下，获取的结果约等于真实内容的宽高（上/左PADDING + 真实内容的高度/宽度）
1.不同浏览器获取的结果不尽相同
2.设置overflow属性值对最后的结果也会产生一定的影响
box.scrollWidth
box.scrollHeight

//获取整个页面真实的高度
document.documentElement.scrollHeight || document.body.scrollHeight

box.scrollTop  竖向滚动条卷去的高度
box.scrollLeft  横向滚动条卷去的宽度

1.边界值
min=0
max=整个的高度scrollHeight - 一屏幕高度clientHeight
2.13个盒子模型属性，只有这两个是“可读写”的属性（既可以获取也可以设置对应的值），
其余的都是“只读”属性（不能设置值，只能获取）

常用：
盒子：
回到顶部：box.scrollTop=0
回到底部：box.scrollTop=box.scrollHeight-box.clientHeight

整个页面：
回到顶部：document.documentElement.scrollTop=0
回到底部：document.documentElement.scrollTop=document.documentElement.scrollHeight-document.documentElement.clientHeight


**获取样式的方法**
window.getComputedStyle([ELEMENT],[伪类]) / [ELEMENT].currentStyle

getComputedStyle
获取当前元素所有经过浏览器计算过的样式
 - 只要元素在页面中呈现出来，那么所有的样式都是经过浏览器计算的
 - 哪怕你没有设置和见过的样式也都计算了
 - 不管你写或者不写，也不轮写在哪，样式都在这，可以直接获取

 

第一个参数是操作的元素  第二个参数是元素的伪类:after/:before
获取的结果是CSSStyleDeclaration这个类的实例（对象），包含了当前元素所有的样式信息
let styleObj = window.getComputedStyle([element],null);
styleObj["backgroundColor"]
styleObj.display

currentStyle
IE6~8
在IE6~8浏览器中不兼容，需要基于currentStyle来获取
styleObj = [element].currentStyle;
*/
      
    </script>
</body>

</html>