<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>基本类型（Undefined、Null、Number）及类型转换</title>
    <script>
    /*
     JS变量类型:
	基本类型（原始值）：字符串(String)、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol（独一无二的值）
     存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。

    引用数据类型（引用值）：对象(Object)、数组(Array)、日期(Date)、正则(RegExp)、函数(Function) 
           基本包装类型：字符串(String)、数字(Number)、布尔(Boolean)
     存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。
    */

        /*
        1 与 Number(1)有什么区别
        */
        var a = new Number(1);
        console.log(typeof 1); //number
        console.log(typeof a); //object
        console.log(1 == a); //true
        console.log(1 instanceof Number); //false
        console.log(a instanceof Number); //true
        console.log(1 === a); //false



        //undefined ：所有没有赋值变量的默认值，自动赋值。
        //1.变量被声明但未初始化时为undefined
        var a;
        console.log(a == undefined); //true
        console.log(a === undefined); //true

        //2.未声明的变量,数据类型为'undefined'
        console.log(typeof b); //'undefined'
        //console.log(b==undefined); b未声明，报错

        //3.数组没有赋值的位置，也为undefined
        var b = [1, 2];
        b[4] = 3;
        console.log(b); //[ 1, 2, undefined, undefined, 3 ]

        //4.对象没有赋值的属性，也为undefined
        var obj = {};
        console.log(obj.name); //undefined

        //5.当函数无明确返回值时，默认返回undefined
        function c() {}
        console.log(c() == undefined); //true
        console.log(c() === undefined); //true


        //null
        //用于表示尚未存在的对象（对象的占位符），或主动释放一个变量引用的对象，表示一个变量不再指向任何对象地址
        //值 undefined 实际上是从值 null 派生来的，因此 ECMAScript 把它们定义为相等的。
        console.log(undefined == null); //true
        console.log(undefined === null); //false
        //当使用完一个比较大的对象时，需要对其进行释放内存时，设置为 null。

        //undefined和null的区分
        //1.两者均为基本类型（原始值），保存在栈中，但数据类型不同
        console.log(typeof undefined); //'undefined'
        console.log(typeof null); //'object'
        /*
        为什么 typeof 运算符对于 null 值会返回 "Object"？
        这实际上是 JavaScript 最初实现中的一个错误，然后被 ECMAScript 沿用了。现在，null 被认为是对象的占位符，从而解释了这一矛盾，但从技术上来说，它仍然是原始值。
        */

        //2.转为布尔类型均为false，但转为数值类型不同
        console.log(Boolean(undefined)); //false
        console.log(Boolean(null)); //false
        console.log(Number(undefined)); //NaN
        console.log(Number(null)); //0

        //3.都没有valueOf()和toString()方法，但可通过String()方法转为字符串类型
        console.log(String(undefined)); //'undefined'
        console.log(String(null)); //'null'



        //Boolean类型
        //true、false
        //Symbol值可以转为布尔值，但是不能转为数值
        /*
        Boolean():将任何类型的值转换为布尔值。
        以下值会被转换为false：
        false、''、0、NaN、null、undefined
        其余任何值都会被转换为true。
        */

        /*
        console.log(!!(new Boolean(false)))输出什么 
        */
        console.log(!!(new Boolean(false))); //true
        console.log((new Boolean(false)).valueOf()); //false



        /*
        Number类型
        这种类型使用IEEE754格式来表示整数和浮点数值 

        整数也可以被表示为八进制（以 8 为底）或十六进制（以 16 为底）的字面量。
        八进制字面量的首数字必须是 0，其后的数字可以是任何八进制数字（0-7），若数值超出范围，被当做十进制来解析
        十六进制字面量的前两位必须是 0x,然后是任意的十六进制数字（0 到 9 和 A 到 F）,大小写不敏感
        尽管所有整数都可以表示为八进制或十六进制的字面量，但所有数学运算返回的都是十进制结果

        要定义浮点值，必须包括小数点和小数点后的一位数字
        也可用科学计数法表示浮点数  浮点数e/E(正整数/负整数)

        特殊的Number值:
        Number.MAX_VALUE和 Number.MIN_VALUE：定义了 Number 值集合的外边界

        当计算生成的数大于 Number.MAX_VALUE 时，它将被赋予值 Number.POSITIVE_INFINITY，意味着不再有数字值。同样，生成的数值小于 Number.MIN_VALUE 的计算
        也会被赋予值 Number.NEGATIVE_INFINITY，也意味着不再有数字值。如果计算返回的是无穷大值，那么生成的结果不能再用于其他计算。Number.POSITIVE_INFINITY 的值为 
        Infinity。Number.NEGATIVE_INFINITY 的值为 -Infinity。
        
        可以对任何数调用 isFinite() 方法，以确保该数不是无穷大,这个函数在参数位于最小最大数值之间时会返回true

        NaN，表示非数（Not a Number）
        任何涉及NaN的操作都会返回NaN
        NaN与任何值都不相等，包括NaN本身
        
        可以对任何数调用 isNaN() 方法，以确定这个数是否“不是数值”。isNaN() 在接收到一个值后，会尝试将其转换为数值，不能转换的返回true（相当于调用了Number()）
        */
        console.log(typeof Number.MAX_VALUE); //number
        console.log(typeof Number.MIN_VALUE); //number
        console.log(typeof Infinity); //number
        console.log(typeof NaN); //number
        console.log(isFinite(NaN)); //false
        console.log(isFinite(Infinity)); //false
        console.log(isFinite(Number.MIN_VALUE)); //true
        /*
        另外，数字属性不可用于变量
        数字属性属于名为 number 的 JavaScript 数字对象包装器。
        这些属性只能作为 Number.MAX_VALUE 访问。
        使用 myNumber.MAX_VALUE，其中 myNumber 是变量、表达式或值，将返回 undefined：
        */
        console.log(Number.NEGATIVE_INFINITY); //-Infinity
        var x = 6;
        console.log(x.NEGATIVE_INFINITY); //undefined

        /*
        isNaN()、Number()、parseInt()、parseFloat()转换见下面类型转换，前两个方法可用于任何数，后两个多用于字符串
        以下三个为Number方法：
        toExponential():返回字符串值，它包含已被四舍五入并使用指数计数法的数字。参数（可选）定义小数点后的字符数
        
        toFixed()：返回字符串值，它包含了指定位数小数的数字。参数定义小数点后的字符数

        toPrecision()： 返回字符串值，它包含了指定长度的数字，参数（可选）定义整个数字的长度
        */



        /*
        valueOf()用于返回指定对象的原始值
        该方法属于Object对象，由于所有的对象都"继承"了Object的对象实例，因此几乎所有的实例对象都可以使用该方法。
        JavaScript的许多内置对象都重写了该函数，以实现更适合自身的功能需要。因此，不同类型对象的valueOf()方法的返回值和返回值类型均可能不同。
        */
        //undefined、null没有valueOf()方法

        //三个基本包装类型返回其基本类型值：
        // 布尔：返回布尔值true或false
        var bool = true;
        console.log(bool.valueOf() === bool); // true
        // new一个Boolean对象
        var bool1 = new Boolean(true);
        // valueOf()返回的是true，两者的值相等
        console.log(bool1.valueOf() == bool1); // true
        // 但是不全等，两者类型不相等，前者是boolean类型，后者是object类型
        console.log(bool1.valueOf() === bool1); // false

        // String：返回字符串值
        var str = "hello";
        console.log(str.valueOf() === str); // true
        // new一个字符串对象
        var str1 = new String("hello");
        // 两者的值相等，但不全等，因为类型不同，前者为string类型，后者为object类型
        console.log(str1.valueOf() === str1); // false

        // Number：返回数字值
        var num = 15.26540;
        console.log(num.valueOf()); // 15.2654
        var num1 = new Number(12); //道理同上
        console.log(num1.valueOf() === num1); //false

        //Array、Function、Object返回其本身
        // Array：返回数组对象本身
        var arr = ["CodePlayer", true, 12, -5]; //等价于arr=new Array("CodePlayer", true, 12, -5);
        console.log(arr.valueOf() === arr); // true

        // Function：返回函数本身
        function foo() {}
        console.log(foo.valueOf() === foo); // true
        var foo2 = new Function("x", "y", "return x + y;");
        console.log(foo2.valueOf() === foo2); // true

        // Object：返回对象本身
        var obj = {
            name: "张三",
            age: 18
        };
        console.log(obj.valueOf() === obj); // true

        //RegExp:返回正则表达式字面量的字符串表示
        console.log(/ab/g.valueOf()); ///ab/g

        // Date：当前时间距1970年1月1日午夜的毫秒数
        var date = new Date(2013, 7, 18, 23, 11, 59, 230);
        console.log(date.valueOf()); // 1376838719230
        /*
        参考：https://blog.csdn.net/celi_echo/article/details/100038366
        */



        /*
        toString()用来返回该对象的字符串
        */
        //undefined、null没有toString()方法
        //Boolean：根据原始布尔值或者 booleanObject 对象的值返回字符串 "true" 或 "false"。
        console.log(true.toString()); //'true'
        var bool = new Boolean(true);
        console.log(bool.toString()); //'true'
        console.log(bool.toString() === bool); //false

        //String:原值返回
        console.log('123'.toString()); //'123'stringObject 的原始字符串值。一般不会调用该方法
        var str = new String("hello");
        console.log(str.toString()); //"hello"
        console.log(str.toString() === str); //false

        //Number类型有两种模式，即默认模式和基模式(参数可选)
        var num = 10;
        // 整数直接跟上.toString()形式，会报错，因为整数后的点会被识别为小数点
        //console.log(10.toString()); 变量名叫identifiers，它符合某些规则，而你打破了这些规则！
        console.log(num.toString()); //'10'
        console.log(num.toString(8)); //'12'

        //正浮点数及NaN、Infinity转换为字符串
        console.log(1.2.toString()); //'1.2'
        console.log(NaN.toString()); //'NaN'
        console.log(Infinity.toString()); //'Infinity'

        //负浮点数或加'+'号的正浮点数直接跟上.toString()，相当于先运行toString()，再添加正负号，转换为数字

        console.log(+1.2.toString()); //1.2
        console.log(typeof + 1.2.toString()); //'number'
        console.log(-1.2.toString()); //-1.2
        console.log(typeof - 1.2.toString()); //'number'

        //因此，为了避免以上无效及报错的情况，数字在使用toString()方法时，加括号可解决
        console.log((10).toString()); //'10'
        console.log((+1.2).toString()); //'1.2'
        console.log((-1.2).toString()); //'-1.2'
        
        //symbol
        var sym =Symbol('me');
        console.log(String(sym));//'Symbol(me)'
        console.log(sym.toString());//'Symbol(me)'
        
        

        // Array: 把数组转换为由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串
        var arr = ["CodePlayer", true, 12, -5];
        console.log(arr.toString()); // 'CodePlayer,true,12,-5'

        //Function：把整个函数转换为字符串（返回函数代码）
        function test() {
            alert(1); //test
        }
        console.log(test.toString());
        /*function test(){
             alert(1);//test
        } */

        //RegExp:返回正则表达式字面量的字符串表示
        console.log(/ab/g.toString()); //'/ab/g'

        //Date: 把 Date 对象转换为字符串
        var date = new Date(2013, 7, 18, 23, 11, 59, 230);
        console.log(date.toString()); // 'Sun Aug 18 2013 23:11:59 GMT+0800 (中国标准时间)'

        //Object类型及自定义对象类型:返回[object Object]
        console.log({}.toString()); //'[object Object]'
        console.log(({}).toString()); //'[object Object]'
        var obj = {
            a: 12
        };
        console.log(obj.toString()); //'[object Object]'

        function Cat() {
            this.name = 'tom';
        }
        var cat1 = new Cat();
        console.log(cat1.toString()); //'[object Object]'
        /*
        参考：https://blog.csdn.net/u011435776/article/details/90230426
        */



        /*
        类型识别
        使用Object.prototype.toString()来进行类型识别，返回代表该对象的[object 数据类型]字符串表示
        Object.prototype.toString()可以识别标准类型及内置对象类型，但不能识别自定义类型
        如果是原始类型，他会将原始类型包装为引用类型
        */

        console.log(Object.prototype.toString.call("jerry")); //'[object String]'
        console.log(Object.prototype.toString.call(12)); //'[object Number]'
        console.log(Object.prototype.toString.call(true)); //'[object Boolean]'
        console.log(Object.prototype.toString.call(undefined)); //'[object Undefined]'
        console.log(Object.prototype.toString.call(null)); //'[object Null]'
        console.log(Object.prototype.toString.call({
            name: "jerry"
        })); //[object Object]
        console.log(Object.prototype.toString.call(function () {})); //'[object Function]'
        console.log(Object.prototype.toString.call([])); //'[object Array]'
        console.log(Object.prototype.toString.call(new Date)); //'[object Date]'
        console.log(Object.prototype.toString.call(/\d/)); //'[object RegExp]'
        function Person() {};
        console.log(Object.prototype.toString.call(new Person)); //'[object Object]'


        function type(obj) {
            return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();

        }

        console.log(type("jerry")); //"string"
        console.log(type(12)); //"number"
        console.log(type(true)); //"boolean"
        console.log(type(undefined)); //"undefined"
        console.log(type(null)); //"null"
        console.log(type({
            name: "jerry"
        })); //"object"
        console.log(type(function () {})); //"function"
        console.log(type([])); //"array"
        console.log(type(new Date)); //"date"
        console.log(type(/\d/)); //"regexp"
        function Person() {};
        console.log(type(new Person)); //"object"
        /*
        参考：https://blog.csdn.net/u011435776/article/details/90230426
        */

        /*
        要求能识别所有原始类型，function,  array,  object,  并可以识别包装类
        */
        function getType(target) {
            //先处理最特殊的Null
            if (target === null) {
                return 'null';
            }
            //判断是不是基础类型
            const typeOfT = typeof target
            if (typeOfT !== 'object') {
                return typeOfT;
            }
            //肯定是引用类型了
            const template = {
                "[object Object]": "object",
                "[object Array]": "array",
                // 一些包装类型
                "[object String]": "object - string",
                "[object Number]": "object - number",
                "[object Boolean]": "object - boolean"
            };
            const typeStr = Object.prototype.toString.call(target);
            return template[typeStr];
        }



        /*
        类型转换方法总结
        */
        //parseInt()
        console.log(parseInt('1234blue')); //1234
        console.log(parseInt('')); //NaN
        console.log(parseInt('0xa')); //10
        console.log(parseInt('AF', 16)); //175

        //parseFloat()
        console.log(parseFloat('1234blue')); //1234
        console.log(parseFloat('0xa')); //0
        console.log(parseFloat('11.22.33')); //11.22
        console.log(parseFloat('3.125e7')); //31250000

        //NaN
        console.log(NaN + 5); //NaN
        console.log(NaN + '5'); //'NaN5'
    </script>
</head>

<body>

</body>

</html>