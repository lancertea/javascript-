<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>object</title>
    <script>
        //
        var obj = {};
        var a = "a";
        obj[a] = true;
        console.log(obj);
        var obj1 = new Set();
        obj1.add(a);
        console.log(obj1);

        

        //for...in
        //for循环的一个变体是for ... in循环，它可以把一个对象的所有属性依次循环出来：
        var o = {
            name: 'Jack',
            age: 20,
            city: 'Beijing'
        };
        for (var key in o) {
            console.log(key); // 'name', 'age', 'city'
        }
        //由于Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for ... in循环可以直接循环出Array的索引：
        var a = ['A', 'B', 'C'];
        for (var i in a) {
            console.log(i); // '0', '1', '2'
            console.log(a[i]); // 'A', 'B', 'C'
        }
        //请注意，for ... in对Array的循环得到的是String而不是Number



        /*
        创建一个空对象
        有时我们需要创建一个纯净的对象, 不包含什么原型链等等. 
        一般创建空对象最直接方式通过字面量 {}, 但这个对象中依然存在 __proto__ 属性来指向 Object.prototype 等等.
        */
        let cle = {};
        console.log(cle.__proto__);
        let cle1 = Object.create(null);
        console.log(cle1.__proto__); //undefined



        /*
        合并对象
        在JavaScript中合并多个对象的需求一直存在, 比如在传参时需要把表单参数和分页参数进行合并后在传递给后端,利用ES6提供的扩展运算符让对象合并变得很简单.
        */
        var page = {
            current: 1,
            pageSize: 10
        }

        var form = {
            name: "",
            sex: ""
        }

        var params = {
            ...form,
            ...page
        };
        console.log(params);
        /*
            {
                name: "",
                sex: "",
                current: 1,
                pageSize: 10

            }
        */



        /*
        call()，apply()，bind()的用法
        https://www.cnblogs.com/Shd-Study/p/6560808.html
        */
        //例1
        var name = "小王",
            age = 17;
        var obj = {
            name: '小张',
            objAge: this.age, //this指向全局
            myFun: function () {
                console.log(this.name + '年龄' + this.age); //this指向对象
                console.log(this.name + '年龄' + this.objAge); //this指向对象
            }
        }
        console.log(obj.objAge); //17
        obj.myFun(); //'小张年龄undefined'
        //'小张年龄17'

        //例2
        var fav = 'klaus';

        function shows() {
            console.log(this.fav); //this指向全局

        }
        shows() //'klaus'

        //call()，apply()，bind()都是用来重定义this这个对象的
        var name = "小王",
            age = 17;
        var obj = {
            name: '小张',
            objAge: this.age, //this指向全局
            myFun: function () {
                console.log(this.name + '年龄' + this.age); //this指向对象

            }
        }
        var db={
            name:'德玛',
            age:99
        }
        obj.myFun.call(db);//'德玛年龄99'
        obj.myFun.apply(db)//'德玛年龄99'
        obj.myFun.bind(db)();//'德玛年龄99'
    //以上除了bind方法后面多了个 () 外 ，结果返回都一致！
    //由此得出结论，bind 返回的是一个新的函数，你必须调用它才会被执行

 

    </script>
</head>

<body>

</body>

</html>