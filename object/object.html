<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>关于对象的问题</title>
    <script>
        //
        var obj = {};
        var a = "a";
        obj[a] = true;
        console.log(obj);
        var obj1 = new Set();
        obj1.add(a);
        console.log(obj1);

        //1.for...in
        //for循环的一个变体是for ... in循环，它可以把一个对象的所有属性依次循环出来：
        var o = {
            name: 'Jack',
            age: 20,
            city: 'Beijing'
        };
        for (var key in o) {
            console.log(key); // 'name', 'age', 'city'
        }
        //由于Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for ... in循环可以直接循环出Array的索引：
        var a = ['A', 'B', 'C'];
        for (var i in a) {
            console.log(i); // '0', '1', '2'
            console.log(a[i]); // 'A', 'B', 'C'
        }
        //请注意，for ... in对Array的循环得到的是String而不是Number




        /*2.Map  (ES6新数据类型)
        https://es6.ruanyifeng.com/#docs/set-map#Set
        JavaScript的默认对象表示方式{}可以视为其他语言中的Map或Dictionary的数据结构，即一组键值对。
        但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。
        为了解决这个问题，最新的ES6规范引入了新的数据类型Map
        Map是一组键值对的结构，具有极快的查找速度。值可修改
        */
        var m = new Map(); // 空Map
        m.set('Adam', 67); // 添加新的key-value
        m.set('Bob', 59);
        console.log(m.has('Adam')); // 是否存在key 'Adam': true
        console.log(m.get('Adam')); // 67
        console.log(m.delete('Adam')); // 删除key 'Adam' 返回 true
        console.log(m.get('Adam')); // undefined

        //只有对同一个对象引用，Map才将其视为同一个键
        var a = {},
            c = a;
        m.set({}, 1);
        console.log(m.get({})); // undefined
        m.set(a, 2);
        console.log(m); //Map(3) { Bob → 59, {} → 1, {} → 2 }
        console.log(m.get(c)); //2
        /*
        由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，
        我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。

        如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，
        布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。
        */

        /*
        属性：
        Map.prototype.constructor：构造函数，默认就是Map函数。
        Map.prototype.size：返回Map实例的成员总数。
        操作方法：
        set(key,value)：设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。
        get(key):读取key对应的键值，如果找不到key，返回undefined。
        has(key)：返回一个布尔值，表示某个键是否在当前 Map 对象之中。
        delete(key)：删除某个键，返回一个布尔值，表示删除是否成功。
        clear()：清除所有成员，没有返回值。
        遍历方法:
        Map的遍历顺序就是插入顺序。
        keys()：返回键名的遍历器
        values()：返回键值的遍历器
        entries()：返回键值对的遍历器
        forEach()：使用回调函数遍历每个成员
        */




        /*3.Set (ES6新数据类型)
        和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。
        */
        var s = new Set([1, 2, 3, 3, '3']);
        console.log(s); // Set {1, 2, 3, "3"}
        console.log(s.add(4)); //Set(5) [ 1, 2, 3, "3", 4 ]
        console.log(s.delete(3)); //true

        //去除数组的重复成员
        console.log([...new Set([1, 2, 3, 3])]); //[ 1, 2, 3 ]
        //Array.from方法可以将 Set 结构转为数组。这也提供了去除数组成员的一种方法
        function dedupe(array) {
            return Array.from(new Set(array));
        }
        console.log(dedupe([1, 1, 2, 3])); // [1, 2, 3]


        //去除字符串里面的重复字符
        console.log([...new Set('ababbc')].join('')); //'abc'

        /*向 Set 加入值的时候，不会发生类型转换，所以5和"5"是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，
        它类似于精确相等运算符（===），主要的区别是向 Set 加入值时认为NaN等于自身，而精确相等运算符认为NaN不等于自身。*/
        var s = new Set();
        var a = NaN,
            b = NaN;
        s.add(a);
        s.add(b);
        console.log(s); //Set [ NaN ]

        //两边都是对象，只要不是同一对象的不同引用，都视为不同值
        var s = new Set();
        var a = {},
            b = {},
            c = a;
        s.add(a);
        s.add(b);
        console.log(s); //Set [ {}, {} ]  其实就是Set [ a,b ] 
        s.add(c);
        console.log(s); //Set [ {}, {} ]  其实就是Set [ a,b ] 因为 c 和 a 引用的是同一个对象，所以是相等的

        /*
        属性：
        Set.prototype.constructor：构造函数，默认就是Set函数。
        Set.prototype.size：返回Set实例的成员总数。
        操作方法：
        add(value)：添加某个值，返回 Set 结构本身。 
        delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
        has(value)：返回一个布尔值，表示该值是否为Set的成员。
        clear()：清除所有成员，没有返回值。
        遍历方法:
        Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。
        keys()：返回键名的遍历器
        values()：返回键值的遍历器
        entries()：返回键值对的遍历器
        forEach()：使用回调函数遍历每个成员
        */


        /*
        4.创建一个空对象
        有时我们需要创建一个纯净的对象, 不包含什么原型链等等. 
        一般创建空对象最直接方式通过字面量 {}, 但这个对象中依然存在 __proto__ 属性来指向 Object.prototype 等等.
        */
        let cle = {};
        console.log(cle.__proto__);
        let cle1 = Object.create(null);
        console.log(cle1.__proto__); //undefined

        /*
        5.合并对象
        在JavaScript中合并多个对象的需求一直存在, 比如在传参时需要把表单参数和分页参数进行合并后在传递给后端,利用ES6提供的扩展运算符让对象合并变得很简单.
        */
        var page = {
            current: 1,
            pageSize: 10
        }

        var form = {
            name: "",
            sex: ""
        }

        var params = {
            ...form,
            ...page
        };
        console.log(params);
        /*
            {
                name: "",
                sex: "",
                current: 1,
                pageSize: 10

            }
        */

        /*
        6.call()，apply()，bind()的用法
        https://www.cnblogs.com/Shd-Study/p/6560808.html
        */
        //例1
        var name = "小王",
            age = 17;
        var obj = {
            name: '小张',
            objAge: this.age, //this指向全局
            myFun: function () {
                console.log(this.name + '年龄' + this.age); //this指向对象
                console.log(this.name + '年龄' + this.objAge); //this指向对象
            }
        }
        console.log(obj.objAge); //17
        obj.myFun(); //'小张年龄undefined'
        //'小张年龄17'

        //例2
        var fav = 'klaus';

        function shows() {
            console.log(this.fav); //this指向全局

        }
        shows() //'klaus'

        //call()，apply()，bind()都是用来重定义this这个对象的
        var name = "小王",
            age = 17;
        var obj = {
            name: '小张',
            objAge: this.age, //this指向全局
            myFun: function () {
                console.log(this.name + '年龄' + this.age); //this指向对象

            }
        }
        var db={
            name:'德玛',
            age:99
        }
        obj.myFun.call(db);//'德玛年龄99'
        obj.myFun.apply(db)//'德玛年龄99'
        obj.myFun.bind(db)();//'德玛年龄99'
    //以上除了bind方法后面多了个 () 外 ，结果返回都一致！
    //由此得出结论，bind 返回的是一个新的函数，你必须调用它才会被执行

 

    </script>
</head>

<body>

</body>

</html>