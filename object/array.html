<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>关于数组的问题</title>
    <script>
        //数组是动态变化的
        //JavaScript的Array可以包含任意数据类型，并通过索引来访问修改每个元素。
        var a = [1, 2, 3.14, 'Hello', null, true];
        a[1] = 99;
        console.log(a); //[1, 99, 3.14, 'Hello', null, true]
        //Array的大小是动态调整的
        a.length = 8;
        console.log(a); //[1, 99, 3.14, 'Hello', null, true，undefined，undefined]



        //避免 使用new Array()
        //arr与arr1都创建了空数组
        var arr = new Array(); // 差
        var arr1 = []; // 优
        //arr2与arr3创建了内容相同的数组
        var arr2 = new Array(40, 100, 1, 5, 25, 10); // 差
        var arr3 = [40, 100, 1, 5, 25, 10]; // 优
        //new 关键词只会使代码复杂化。它还会产生某些不可预期的结果
        console.log(new Array(1, 2)); //[ 1, 2 ]
        console.log(new Array(2)); //创建包含 2个未定义元素的数组



        //判断一个数据是不是数组
        var arr = [1, 2, 3];
        var obj = {};
        //1.Array.isArray(obj)
        //ECMAScript 5种的函数，当使用ie8的时候就会出现问题
        console.log(Array.isArray(arr)); //true
        console.log(Array.isArray(obj)); //false

        //2.obj instanceof Array
        //当用来检测在不同的window或iframe里构造的数组时会失败。这是因为每一个iframe都有它自己的执行环境，彼此之间并不共享原型链，
        //所以此时的判断一个对象是否为数组就会失败。
        console.log(arr instanceof Array); //true
        console.log(obj instanceof Array); //false

        //3.Object.prototype.toString.call(obj) == '[object Array]' 
        console.log(Object.prototype.toString.call(arr) == '[object Array]'); //true

        //4.obj.constructor === Array
        console.log(arr.constructor === Array); //true
        //5
        function isArr(x) {
            return x.constructor.toString().indexOf("Array") > -1;
        }
        console.log(isArr(arr)); //true



        //复制数组的方法
        var a = [1, 2, 3, 4, 5];
        var acopy = a.slice();
        console.log(acopy); //[1,2,3,4,5]
        console.log(a === acopy); //false 返回的是原数组的副本

        var acopy1 = a.concat();
        console.log(acopy1); //[1,2,3,4,5]
        console.log(a === acopy1); //false 返回的是原数组的副本

        //错误示例：不要用改变原数组的方法去复制数组，这样对新数组操作时，原数组也会改变
        var acopy2 = a.copyWithin(0); //a2.copyWithin(0,0)也可
        console.log(acopy2); //[1,2,3,4,5]
        console.log(a); //[1,2,3,4,5]
        console.log(a === acopy2); //true  在原数组上做修改
        acopy2.push(6);
        console.log(acopy2); //[1,2,3,4,5,6]
        console.log(a); //[1,2,3,4,5,6]



        /*
        Array对象常用方法总结
        改变原数组：
        copyWithin()
        在数组内部，将一段元素序列拷贝到另一段元素序列上，覆盖原有的值
        fill()
        将数组中指定区间的所有元素的值，都替换成某个固定的值。
        push()
        在数组的末尾增加一个或多个元素，并返回数组的新长度。
        pop()
        删除数组的最后一个元素，并返回这个元素。
        shift()
        删除数组的第一个元素，并返回这个元素。
        unshift()
        在数组的开头增加一个或多个元素，并返回数组的新长度。
        reverse()
        颠倒数组中元素的排列顺序，即原先的第一个变为最后一个，原先的最后一个变为第一个。
        sort()
        对数组元素进行排序，并返回当前数组。
        splice()
        在任意的位置给数组添加或删除任意个元素。

        不改变原数组，只会返回一个新的数组或返回一个其它的期望值：
        join()
        连接所有数组元素组成一个字符串。
        slice()
        抽取当前数组中的一段元素组合成一个新数组。
        concat()
        返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组。
        includes()
        判断当前数组是否包含某指定的值，如果是返回 true，否则返回 false。
        indexOf()
        返回数组中第一个与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。
        lastIndexOf()
        返回数组中最后一个（从右边数第一个）与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。
        toSource()
        返回一个表示当前数组字面量的字符串。遮蔽了原型链上的 Object.prototype.toSource() 方法。
        toString()
        返回一个由所有数组元素组合而成的字符串。遮蔽了原型链上的 Object.prototype.toString() 方法。
        toLocaleString()
        返回一个由所有数组元素组合而成的本地化后的字符串。遮蔽了原型链上的 Object.prototype.toLocaleString() 方法。

        迭代方法
        在下面的众多遍历方法中，有很多方法都需要指定一个回调函数作为参数。在每一个数组元素都分别执行完回调函数之前，数组的length属性会被缓存在某个地方，
        所以，如果你在回调函数中为当前数组添加了新的元素，那么那些新添加的元素是不会被遍历到的。此外，如果在回调函数中对当前数组进行了其它修改，
        比如改变某个元素的值或者删掉某个元素，那么随后的遍历操作可能会受到未预期的影响。总之，不要尝试在遍历过程中对原数组进行任何修改，
        虽然规范对这样的操作进行了详细的定义，但为了可读性和可维护性，请不要这样做。
        forEach()
        为数组中的每个元素执行一次回调函数。
        map()
        返回一个由回调函数的返回值组成的新数组。
        reduce()
        从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。
        filter()
        将所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回。
        every()
        如果数组中的每个元素都满足测试函数，则返回 true，否则返回 false。
        some()
        如果数组中至少有一个元素满足测试函数，则返回 true，否则返回 false。
        find()
        找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，则返回 undefined。
        findIndex()
        找到第一个满足测试函数的元素并返回那个元素的索引，如果找不到，则返回 -1。
        keys()
        返回一个数组迭代器对象，该迭代器会包含所有数组元素的键。
        entries()
        返回一个数组迭代器对象，该迭代器会包含所有数组元素的键值对。
        */



        //数组去重的方法
        //1.Set()
        var arr = [1, 2, 3, 3, 4];
        console.log(...new Set(arr)); //1,2,3,4
        console.log([...new Set(arr)]); //[1,2,3,4]

        function dedupe(array) {
            return Array.from(new Set(array));

        }

        console.log(dedupe(arr)); //[1,2,3,4]

        //2.filter()
        //filter()接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。
        //回调函数还可以接收另外两个参数，表示元素的位置和数组本身：
        var arr = ['A', 'B', 'C'];
        var r = arr.filter(function (element, index, self) {
            console.log(element); // 依次打印'A', 'B', 'C'
            console.log(index); // 依次打印0, 1, 2
            console.log(self); // self就是变量arr
        });
        //去除重复元素依靠的是indexOf总是返回第一个元素的位置，后续的重复元素位置与indexOf返回的位置不相等，因此被filter滤掉了。
        var
            r,
            arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry'];
        r = arr.filter(function (element, index, self) {
            return self.indexOf(element) === index;
        });
        console.log(r); //['apple', 'strawberry', 'banana', 'pear',  'orange']



        /*
        过滤数组
        有时我们需要过滤数组中值为 false 的值. 例如(0, undefined, null, false)，可传入一个 Boolean 函数
        */
        var arr = [1, 0, undefined, null, false, ''];
        console.log(arr.filter(Boolean)); //[1] Boolean()对' '、{}为true,无法过滤

        var arr1 = [1, 0, undefined, null, false, '', ' ', {}];
        // var r = arr.filter(function (s) {
        //     return s && s.trim();
        // });

        console.log(arr1.filter(Number)); //[1]




        /*
        concat()方法
        用于连接两个或多个数组
        不改变原数组、返回被连接数组的副本
        */
        var colors = ["red", "green", "blue"];
        var colors1 = colors.concat("yellow", ["black", "brown"]);
        var colors2 = colors.concat("yellow", ["black", "brown", ["white", "grey"]]);

        console.log(colors); //["red", "green", "blue"]       
        console.log(colors1); //["red", "green", "blue", "yellow", "black", "brown" ]
        console.log(colors2); //["red", "green", "blue", "yellow", "black", "brown",["white","grey"]]

        /*
        copyWithin()方法
        用于从数组的指定位置拷贝元素到数组的另一个指定位置
        改变原数组
        array.copyWithin(target, start, end)
        target: 必需。复制到指定目标索引位置
        start : 可选。元素复制的起始位置
        end:    可选。停止复制的索引位置 (默认为 array.length)。如果为负值，表示倒数
        */
        var a = [1, 2, 3, 4, 5];
        console.log(a.copyWithin(0, 2)); //[ 3, 4, 5, 4, 5 ]
        console.log(a); //[ 3, 4, 5, 4, 5 ] 改变原数组
        var acopy = [1, 2, 3, 4, 5];
        console.log(acopy.copyWithin(2, 0, 2)); //[1,2,1,2,5]
        var acopy1 = [1, 2, 3, 4, 5];
        console.log(acopy1.copyWithin(1, 0, -2)); //[1,1,2,3,5]

        /*
        splice()方法
        splice() 方法用于添加或删除数组中的元素。
        这种方法会改变原始数组。
        */
        var colors = ["red", "green", "blue"];
        var removed = colors.splice(0, 1); //移除第一项
        console.log(colors); // [green", "blue" ]
        console.log(removed); // [ "red"]

        removed = colors.splice(1, 0, "yellow", "orange"); //在索引为1的位置插入两项
        console.log(colors); //[ "green", "yellow", "orange", "blue" ]
        console.log(removed); //[]

        removed = colors.splice(1, 1, "red", "purple"); //i在索引为1的位置删除一项，插入两项
        console.log(colors); //[ "green", "red", "purple", "orange", "blue" ]
        console.log(removed); //[ "yellow" ]



        /*
        delete操作符
        delete 操作符用于删除对象的某个属性；如果没有指向这个属性的引用，那它最终会被释放。
        */

        var obj = {
            age: 25,
            weight: 80,
            height: 168,
            sayHi: function () {
                console.log("hi");
            }
        };
        //delete 操作符会从某个对象上移除指定属性。成功删除的时候返回 true
        console.log(delete obj.age); //true
        console.log(obj); //Object { weight: 80, height: 168, sayHi: sayHi()}
        //如果试图删除的属性不存在，那么delete将不会起任何作用，但仍会返回true
        console.log(delete obj.gender); //true

        //如果对象的原型链上有一个与待删除属性同名的属性，那么删除属性之后，
        //对象会使用原型链上的那个属性（也就是说，delete操作只会在自身的属性上起作用）
        function Person(name, age, job) {
            this.name = name;
            this.age = age;
            this.job = job;
            this.sayName = function () {
                console.log(this.name);

            };
        }
        Person.prototype.job = "engineer";
        var person1 = new Person("jane", 25, "teacher");
        console.log(person1); //Object { name: "jane", age: 25, job: "teacher", sayName: sayName()}
        console.log(delete person1.job); //true
        console.log(person1); //Object { name: "jane", age: 25, sayName: sayName()}
        console.log(person1.job); //engineer
        console.log(delete person1.job); //true
        console.log(person1.job); //engineer

        /*
        任何使用 var 声明的属性不能从全局作用域或函数的作用域中删除。 
        任何用let或const声明的属性不能够从它被声明的作用域中删除。
        这样的话，delete操作不能删除任何在全局作用域中的函数（无论这个函数是来自于函数声明或函数表达式）
        除了在全局作用域中的函数不能被删除，在对象(object)中的函数是能够用delete操作删除的。
        */
        var a = 1;
        let aa = 2;
        const aaa = 3;
        delete a;
        console.log(a); //1
        delete aa;
        console.log(aa); //2
        delete aaa;
        console.log(aaa); //3

        function hello() {
            console.log("hello");

        }
        delete hello;
        hello(); //hello

        // Person.sayName =function(){
        //     console.log(this.name);

        // }
        person1.sayName(); //jane
        delete Person.sayName;
        person1.sayName(); //jane

        obj.sayHi(); //hi
        delete obj.sayHi;
        console.log(obj); //Object { weight: 80, height: 168 }
        obj.sayBye = function () {
            console.log("bye");
        };
        console.log(obj); //Object { weight: 80, height: 168, sayBye: sayBye()}


        //当你删除一个数组元素时，数组的长度不受影响。即便你删除了数组的最后一个元素也是如此。
        //当用 delete 操作符删除一个数组元素时，被删除的元素已经不再属于该数组。
        var a = [1, 2, 3, 4, 5];
        delete a[2];
        console.log(a); //[1, 2, <1 empty slot>, 4, 5]
        if (2 in a)
            console.log("bye"); //不执行

        //如果你想让一个数组元素继续存在但是其值是 undefined，
        //那么可以使用将 undefined 赋值给这个元素而不是使用 delete。
        var a = [1, 2, 3, 4, 5];
        a[2] = undefined;
        if (2 in a)
            console.log("bye"); //bye

        //想要删除数组
        var a = [1, 2, 3, 4, 5];
        console.log(a.pop()); //5
        console.log(a); //[1, 2, 3, 4]
        console.log(a.shift()); //1
        console.log(a); //[2, 3, 4]
        console.log(a.splice(1, 1)); //[3]
        console.log(a); //[2,4]
        
    </script>
</head>

<body>

</body>

</html>