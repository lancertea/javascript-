<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>手写promise</title>
</head>

<body>
    <script>
        class MyPromise {
            constructor(executor) {
                //每个Promise实例都有一个状态和结果属性
                this.status = 'pending';
                this.value = undefined;

                //用来存储基于then指定的成功或者失败的方法
                this.resolveArr = [];
                this.rejectArr = [];

                //定义resolve/reject方法用来改变promise实例的状态和结果
                let change = (status, value) => {
                    //状态一旦改变过，再改变则无效
                    if (this.status !== 'pending') {
                        return;
                    }
                    this.status = status;
                    this.value = value;
                    // 改变完成状态后，把基于then指定的对应方法执行

                    let fnArr = status === 'fulfilled' ? this.resolveArr : this.rejectArr;
                    fnArr.forEach(item => {
                        if (typeof item !== 'function')
                            return;
                        item(this.value);
                    })
                };

                //为了保证执行resolve/reject的时候，已经通过then把需要执行的方法弄好了，需要判断处理:
                //没有方法的时候，我们让改变状态的操作延迟进行
                let resolve = result => {
                    if (this.resolveArr.length > 0) {
                        change('fulfilled', result);
                        return;
                    }
                    let delayTimer = setTimeout(_ => {
                        change('fulfilled', result);
                        clearTimeout(delayTimer);
                    }, 0);
                };

                let reject = reason => {
                    if (this.rejectArr.length > 0) {
                        change('rejected', reason);
                        return;
                    }
                    let delayTimer = setTimeout(_ => {
                        change('rejected', reason);
                        clearTimeout(delayTimer);
                    }, 0);

                };

                //每一次new Promise都会立即执行executor函数
                try {
                    executor(resolve, reject);
                } catch (err) {
                    reject(err, message);
                }

            }
            //MyPromise.prototype.then
            then(resolveFn, rejectFn) {
                //每一次执行then都会返回一个新的promise实例

                //如果传递的参数不是函数(null/不传递)，我们让成功或者失败顺延
                if (typeof resolveFn !== "function") {
                    resolveFn = result => {
                        return MyPromise.resolve(result);
                    };
                }
                if (typeof rejectFn !== "function") {
                    rejectFn = reason => {
                        return MyPromise.reject(reason);
                    };
                }

                return new MyPromise((resolve, reject) => {
                    //只要执行新实例的executor函数中的resolve/reject就能知道新的实例是成功还是失败的
                    // this.resolveArr.push(resolveFn);
                    // this.rejectArr.push(rejectFn);
                    this.resolveArr.push(result => {
                        try {
                            //不报错，则接受方法的返回结果，会根据结果判断成功还是失败
                            let x = resolveFn(result);
                            if (x instanceof MyPromise) {
                                x.then(resolve, reject);
                                return;
                            }
                            resolve(x);
                        } catch (err) {
                            //方法执行报错，也代表新实例是失败的
                            reject(err.message);
                        }

                    });
                    this.rejectArr.push(reason => {
                        try {
                            let x = rejectFn(reason);
                            if (x instanceof MyPromise) {
                                x.then(resolve, reject);
                                return;
                            }
                            resolve(x);
                        } catch (err) {
                            reject(err.message);
                        }

                    })

                });
            }

            catch () {
                return this.then(null, rejectFn);
            }

            static resolve(result) {
                return new MyPromise((resolve, reject) => {
                    resolve(result);
                });
            }

            static reject(reason) {
                return new MyPromise((resolve, reject) => {
                    reject(reason);
                });
            }

            static all(arr) {
                return new MyPromise((resolve, reject) => {
                    let index = 0,
                        results = [];
                    for (let i = 0; i < arr.length; i++) {
                        let item = arr[i];
                        if (!(item instanceof MyPromise)) continue;
                        item.then(result => {
                            index++;
                            results[i] = result;
                            if (index === arr.length) {
                                resolve(results);
                            }
                        }).catch(reason => {
                            reject(reason);
                        });
                    }
                });
            }
        }

        new MyPromise((resolve, reject) => {
            setTimeout(_ => {
                // resolve(100);
                reject('error');
            }, 1000);

        }).then(result => {
            console.log(result);
            return 200;
        }, reason => {
            console.log(reason);
            return "ok";
        }).then(result => {
            console.log(result);

        }, reason => {
            console.log(reason);

        });

        // new MyPromise((resolve, reject) => {
        //     setTimeout(_ => {
        //         // resolve(100);
        //         reject('ERROR');
        //     }, 1000);
        // }).catch(reason => {
        //     // return Promise.reject(reason);
        // }).then(result => {
        //     return result;
        // }).then(result => {

        // });

        // MyPromise.all([...]).then();
    </script>
</body>

</html>